<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dist/matchers.js - angular-jasmine-matchers</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="angular-jasmine-matchers" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/matchers.html">matchers</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: dist/matchers.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 (c) Ferron Hanse 2012
 https://github.com/ferronrsmith/anuglarjs-jasmine-matchers
 Released under the MIT license
 */


/*jslint nomen : true*/
/*jslint devel : true*/
/*jslint unparam : true */
/*jslint browser : true */
/*jslint bitwise : true*/
/*global describe, beforeEach, inject, module, angular, document, it, expect, $, jasmine, toJson */

/**
 Provides a comprehensive set of custom matchers for the Jasmine testing framework
 @class matchers
 @main matchers
 **/
beforeEach(function () {
    &quot;use strict&quot;;
    var customMatchers = {},
        matchers = {},
        hlp = {},
        bjQuery = false;

    hlp.cssMatcher = function (presentClasses, absentClasses) {
        var self = this;
        return function () {
            var element = angular.element(self.actual), present = true, absent = false;

            angular.forEach(presentClasses.split(&#x27; &#x27;), function (className) {
                present = present &amp;&amp; element.hasClass(className);
            });

            angular.forEach(absentClasses.split(&#x27; &#x27;), function (className) {
                absent = absent || element.hasClass(className);
            });

            self.message = function () {
                return &quot;Expected to {0} have &quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + presentClasses +
                    (absentClasses ? (&quot; and not have &quot; + absentClasses + &quot; &quot;) : &quot;&quot;) +
                    &quot; but had &quot; + element[0].className + &quot;.&quot;;
            };
            return present &amp;&amp; !absent;
        };
    };

    /**
     * Returns the index of an object in a given array
     * @method hpl.indexOf
     * @param array :- array object to be checked
     * @param obj :- object (value) to be checked for in the array
     * @return {number} index of the obj in the array
     */
    hlp.indexOf = function (array, obj) {
        var i;
        for (i = 0; i &lt; array.length; i += 1) {
            if (obj === array[i]) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Check if an object has a particular property matches the expected value
     * @method hpl.hasProperty
     * @param actualValue property value
     * @param expectedValue expected value
     * @return {boolean} boolean indicating if the values match
     */
    hlp.hasProperty = function (actualValue, expectedValue) {
        if (expectedValue === undefined) {
            return actualValue !== undefined;
        }
        return actualValue === expectedValue;
    };

    /**
     * Returns the type of the object entered
     * @param actual -  object to be checked
     */
    hlp.typeOf = function (actual) {
        return Object.prototype.toString.call(actual).replace(/(\[|object|\s|\])/g, &quot;&quot;).toLowerCase();
    };

    /**
     * Checks if a given element/JavaScript object matches the type
     * @method hpl.isOfType
     * @param actual Object to be checked for type comparison
     * @param type type to be matched
     * @return {boolean} boolean indicating if the type matches the object type
     */
    hlp.isOfType = function (actual, type) {
        return hlp.typeOf(actual) === type.toLowerCase();
    };

    /**
     * Checks if the a given word/phrase/substring is at the end of a string
     * @method hpl.endsWith
     * @param {String} haystack string to be search
     * @param needle {String} word/phrase/substring
     * @return {boolean} boolean indicating if the word/phrase/substring was found at the end of the string
     */
    hlp.endsWith = function (haystack, needle) {
        return haystack.substr(-needle.length) === needle;
    };

    /**
     * Checks if the a given word/phrase/substring is at the beginning of a string
     * @method hpl.endsWith
     * @param {String} haystack string to be search
     * @param needle {String} word/phrase/substring
     * @return {boolean} boolean indicating if the word/phrase/substring was found at the beginning of the string
     */
    hlp.startsWith = function (haystack, needle) {
        return haystack.substr(0, needle.length) === needle;
    };

    /**
     * Coverts a given object literal to an array
     * @method hlp.objToArray
     * @param obj - object literal
     * @return {Array} array representation of the object
     * @since 0.2 :- Removed $$hashKey check
     */
    hlp.objToArray = function (obj) {
        var arr = [], aDup = {};
        angular.copy(obj, aDup);
        angular.forEach(aDup, function (value, key) {
            arr.push(value);
        });
        return arr;
    };

    /**
     * Coverts a given a list of object literals to a flatten array
     * @method hlp.objListToArray
     * @param obj - object literals
     * @return {Array} flatten array representation of the objects
     */
    hlp.objListToArray = function (obj) {
        var res = [];
        angular.forEach(obj, function (value, key) {
            res = res.concat(hlp.objToArray(value));
        });
        return res;
    };

    hlp.isNumber = function (val) {
        return !isNaN(parseFloat(val)) &amp;&amp; !hlp.isOfType(val, &#x27;String&#x27;);
    };

    /**
     * Message constant for jQuery
     * @type {string}
     */
    hlp.msg = {
        jQuery: &quot;Error: jQuery not found. this matcher has a dependency on jQuery&quot;,
        date: {
            invalidType: &#x27;Expected {0} &amp; {1} to be a Date&#x27;,
            nomatch: {
                Date: &#x27;Expected {0} &amp; {1} to match&#x27;,
                part: &quot;Invalid part : {0} entered&quot;
            }
        }
    };

    hlp.dp = function (x) {
        return angular.mock.dump(arguments.length &gt; 1 ? arguments : x);
    };

    /**
     * Returns isNot String
     * @param context
     * @param altText
     */
    hlp.isNot = function (context, altText) {
        altText = altText || &quot;&quot;;
        return context.isNot ? &quot;not &quot; : altText;
    };

    hlp.evaluate = function (test) {
        return {
            compare: function (actual, expected) {
                return test(actual, false, expected);
            },
            negativeCompare: function (actual, expected) {
                return test(actual, true, expected);
            }
        };
    };

    hlp.checkArgumentType = function (value, type) {
        var result = hlp.isOfType(value, type);
        if (!result) {
            throw new Error(&quot;Invalid type detected, Expected [{0}], but was [{1}]&quot;.t(type, hlp.typeOf(value)));
        }
    };


    String.prototype.t = function () {
        var args = arguments;
        return this.replace(/\{(\d+)\}/g, function (match, number) {
            return args[number] !== &#x27;undefined&#x27; ? args[number] : match;
        });
    };

    /**
     * Check if jQuery is present
     * @return {boolean} boolean indicating if jQuery is present
     */
    bjQuery = (function () {
        return (window.$ !== undefined || window.jQuery !== undefined);
    }());

    customMatchers.toBeInvalid = hlp.cssMatcher(&#x27;ng-invalid&#x27;, &#x27;ng-valid&#x27;);
    customMatchers.toBeValid = hlp.cssMatcher(&#x27;ng-valid&#x27;, &#x27;ng-invalid&#x27;);
    customMatchers.toBeDirty = hlp.cssMatcher(&#x27;ng-dirty&#x27;, &#x27;ng-pristine&#x27;);
    customMatchers.toBePristine = hlp.cssMatcher(&#x27;ng-pristine&#x27;, &#x27;ng-dirty&#x27;);
    customMatchers.toEqual = function (expected) {
        if (this.actual &amp;&amp; this.actual.$$log) {
            if (typeof expected === &#x27;string&#x27;) {
                this.actual = this.actual.toString();
            } else {
                this.actual = this.actual.toArray();
            }
        }
        return jasmine.Matchers.prototype.toEqual.call(this, expected);
    };

    customMatchers.toEqualData = function (expected) {
        this.message = function () {
            return &quot;Expected &quot; + hlp.dp(this.actual) + &quot; data {0} to Equal &quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + expected;
        };
        return angular.equals(this.actual, expected);
    };

    customMatchers.toEqualError = function (message) {
        this.message = function () {
            var expected;
            if (this.actual.message &amp;&amp; this.actual.name === &#x27;Error&#x27;) {
                expected = angular.toJson(this.actual.message);
            } else {
                expected = angular.toJson(this.actual);
            }
            return &quot;Expected &quot; + expected + &quot; to {0} be an Error with message &quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + angular.toJson(message);
        };
        return this.actual.name === &#x27;Error&#x27; &amp;&amp; this.actual.message === message;
    };

    customMatchers.toMatchError = function (messageRegexp) {
        this.message = function () {
            var expected;
            if (this.actual.message &amp;&amp; this.actual.name === &#x27;Error&#x27;) {
                expected = angular.toJson(this.actual.message);
            } else {
                expected = angular.toJson(this.actual);
            }
            return &quot;Expected &quot; + expected + &quot; to {0} match an Error with message &quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + angular.toJson(messageRegexp);
        };
        return this.actual.name === &#x27;Error&#x27; &amp;&amp; messageRegexp.test(this.actual.message);
    };

    customMatchers.toHaveBeenCalledOnce = function () {
        if (arguments.length &gt; 0) {
            throw new Error(&#x27;toHaveBeenCalledOnce does not take arguments, use toHaveBeenCalledWith&#x27;);
        }

        if (!jasmine.isSpy(this.actual)) {
            throw new Error(&#x27;Expected a spy, but got &#x27; + jasmine.pp(this.actual) + &#x27;.&#x27;);
        }

        this.message = function () {
            var msg = &#x27;Expected spy &#x27; + this.actual.identity + &#x27; to have been called once, but was &#x27;,
                count = this.actual.callCount;
            return [
                count === 0 ? msg + &#x27;never called.&#x27; : msg + &#x27;called &#x27; + count + &#x27; times.&#x27;,
                msg.replace(&#x27;to have&#x27;, &#x27;not to have&#x27;) + &#x27;called once.&#x27;
            ];
        };

        return this.actual.callCount === 1;
    };

    customMatchers.toHaveBeenCalledOnceWith = function () {
        var expectedArgs = jasmine.util.argsToArray(arguments);

        if (!jasmine.isSpy(this.actual)) {
            throw new Error(&#x27;Expected a spy, but got &#x27; + jasmine.pp(this.actual) + &#x27;.&#x27;);
        }

        this.message = function () {
            var result;
            if (this.actual.callCount !== 1) {
                if (this.actual.callCount === 0) {
                    result = [
                        &#x27;Expected spy &#x27; + this.actual.identity + &#x27; to have been called with &#x27; +
                            jasmine.pp(expectedArgs) + &#x27; but it was never called.&#x27;,
                        &#x27;Expected spy &#x27; + this.actual.identity + &#x27; not to have been called with &#x27; +
                            jasmine.pp(expectedArgs) + &#x27; but it was.&#x27;
                    ];
                } else {
                    result = [
                        &#x27;Expected spy &#x27; + this.actual.identity + &#x27; to have been called with &#x27; +
                            jasmine.pp(expectedArgs) + &#x27; but it was never called.&#x27;,
                        &#x27;Expected spy &#x27; + this.actual.identity + &#x27; not to have been called with &#x27; +
                            jasmine.pp(expectedArgs) + &#x27; but it was.&#x27;
                    ];
                }
            } else {
                result = [
                    &#x27;Expected spy &#x27; + this.actual.identity + &#x27; to have been called with &#x27; +
                        jasmine.pp(expectedArgs) + &#x27; but was called with &#x27; + jasmine.pp(this.actual.argsForCall),
                    &#x27;Expected spy &#x27; + this.actual.identity + &#x27; not to have been called with &#x27; +
                        jasmine.pp(expectedArgs) + &#x27; but was called with &#x27; + jasmine.pp(this.actual.argsForCall)
                ];
            }
            return result;
        };

        return this.actual.callCount === 1 &amp;&amp; this.env.contains_(this.actual.argsForCall, expectedArgs);
    };

    customMatchers.toBeOneOf = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be one of &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + hlp.dp(arguments) + &quot;&#x27;.&quot;;
        };
        return hlp.indexOf(arguments, this.actual) !== -1;
    };

    customMatchers.toHaveClass = function (clazz) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have class &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + clazz + &quot;&#x27;.&quot;;
        };
        return this.actual.hasClass ? this.actual.hasClass(clazz) : angular.element(this.actual).hasClass(clazz);
    };

    customMatchers.toHaveCss = function (css) {
        var prop; // css prop
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have css &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + hlp.dp(css) + &quot;&#x27;.&quot;;
        };
        for (prop in css) {
            if (css.hasOwnProperty(prop)) {
                if (this.actual.css(prop) !== css[prop]) {
                    return false;
                }
            }
        }
        return true;
    };

    customMatchers.toMatchRegex = function (regex) {

        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} match &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + regex;
        };

        var reg;
        if (hlp.isOfType(regex, &quot;String&quot;)) {
            reg = new RegExp(regex);
        } else if (hlp.isOfType(regex, &quot;RegExp&quot;)) {
            reg = regex;
        }
        return reg.test(this.actual);
    };

    customMatchers.toBeVisible = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be visible &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return this.actual.is(&#x27;:visible&#x27;);
    };

    customMatchers.toBeHidden = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be hidden &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return this.actual.is(&#x27;:hidden&#x27;);
    };

    customMatchers.toBeSelected = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be selected &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return this.actual.is(&#x27;:selected&#x27;);
    };

    customMatchers.toBeChecked = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be checked &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return this.actual.is(&#x27;:checked&#x27;);
    };

    customMatchers.toBeSameDate = function (date) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be equal to &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + hlp.dp(date);
        };

        var actualDate = this.actual;
        return actualDate.getDate() === date.getDate() &amp;&amp;
            actualDate.getFullYear() === date.getFullYear() &amp;&amp;
            actualDate.getMonth() === date.getMonth() &amp;&amp;
            actualDate.getHours() === date.getHours() &amp;&amp;
            actualDate.getMinutes() === date.getMinutes() &amp;&amp;
            actualDate.getSeconds() === date.getSeconds();
    };

    customMatchers.toBeEmpty = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be empty &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return this.actual.is(&#x27;:empty&#x27;);
    };

    customMatchers.toBeEmptyString = function () {
        this.message = function () {
            return &quot;Expected string &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be empty &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return hlp.isOfType(this.actual, &#x27;String&#x27;) &amp;&amp; $.trim(this.actual).length === 0;
    };

    customMatchers.toExist = function () {
        this.message = function () {
            var msg = &quot;&quot;;
            if (bjQuery) {
                msg = &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} exists &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
            } else {
                msg = hlp.msg.jQuery;
            }
            return msg;
        };
        return bjQuery ? $(document).find(this.actual).length : false;
    };

    customMatchers.toHaveAttr = function (attributeName, expectedAttributeValue) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have attribute &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + attributeName + &quot;&#x27; with value &quot; + expectedAttributeValue + &quot;.&quot;;
        };
        return hlp.hasProperty(this.actual.attr(attributeName), expectedAttributeValue);
    };

    customMatchers.toHaveProp = function (propertyName, expectedPropertyValue) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have property &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + expectedPropertyValue + &quot;&#x27;.&quot;;
        };
        return hlp.hasProperty(this.actual.prop(propertyName), expectedPropertyValue);
    };

    customMatchers.toHaveId = function (id) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have id &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + id + &quot;&#x27;.&quot;;
        };
        return this.actual.attr(&#x27;id&#x27;) === id;
    };

    customMatchers.toBeDisabled = function (selector) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be disabled &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + hlp.dp(selector) + &quot;&#x27;.&quot;;
        };
        return this.actual.is(&#x27;:disabled&#x27;);
    };

    customMatchers.toBeFocused = function (selector) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be focused &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + hlp.dp(selector) + &quot;&#x27;.&quot;;
        };
        return this.actual.is(&#x27;:focus&#x27;);
    };

    customMatchers.toHaveText = function (text) {
        if (!bjQuery) {
            return false;
        }

        this.message = function () {
            var msg = &quot;&quot;;
            if (bjQuery) {
                msg = &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have text &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + text + &quot;&#x27;.&quot;;
            } else {
                msg = hlp.msg.jQuery;
            }
            return msg;
        };

        var trimmedText = $.trim(this.actual.text()), result;
        if (text &amp;&amp; angular.isFunction(text.test)) {
            result = text.test(trimmedText);
        } else {
            result = trimmedText === text;
        }
        return result;
    };

    customMatchers.toHaveValue = function (value) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have value &#x27;&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + value + &quot;&#x27;.&quot;;
        };
        return this.actual.val() === value;
    };

    customMatchers.toHaveData = function (key, expectedValue) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} have data &#x27;&quot; + expectedValue + &quot;&#x27;.&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return hlp.hasProperty(this.actual.data(key), expectedValue);
    };

    /**
     * Does not return true if subject is null
     * @return {Boolean}
     */
    customMatchers.toBeObject = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be an [Object]&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return hlp.isOfType(this.actual, &#x27;Object&#x27;);
    };


    /**
     * @return {Boolean}
     */
    customMatchers.toBeArray = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be an [Array]&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return hlp.isOfType(this.actual, &#x27;Array&#x27;);
    };

    /**
     * @return {Boolean}
     */
    customMatchers.toBeDate = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be a [Date]&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return hlp.isOfType(this.actual, &#x27;Date&#x27;);
    };

    /**
     * @return {Boolean}
     */
    customMatchers.toBeBefore = function (date) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be before&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + hlp.dp(date);
        };
        return hlp.isOfType(this.actual, &#x27;Date&#x27;) &amp;&amp; this.actual.getTime() &lt; date.getTime();
    };

    /**
     * @return {Boolean}
     */
    customMatchers.toBeAfter = function (date) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be after&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;) + hlp.dp(date);
        };
        return hlp.isOfType(this.actual, &#x27;Date&#x27;) &amp;&amp; this.actual.getTime() &gt; date.getTime();
    };

    matchers.toBeIso8601Date = function () {
        return {
            compare: function (actual) {
                return {
                    pass: hlp.isOfType(actual, &#x27;String&#x27;)
                        &amp;&amp; actual.length &gt;= 10
                        &amp;&amp; new Date(actual).toString() !== &#x27;Invalid Date&#x27;
                        &amp;&amp; new Date(actual).toISOString().slice(0, actual.length) === actual
                };
            }
        };
    };

    /**
     * Asserts subject is an Array with a defined number of members
     * @param  {Number} size
     * @return {Boolean}
     */
    customMatchers.toBeArrayOfSize = function (size) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be an [Array] of size {1}&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;, size);
        };
        return hlp.isOfType(this.actual, &#x27;Array&#x27;) &amp;&amp; this.actual.length === size;
    };

    /**
     * @return {Boolean}
     */
    customMatchers.toBeString = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be a [String]&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return hlp.isOfType(this.actual, &#x27;String&#x27;);
    };

    /**
     * @return {Boolean}
     */
    customMatchers.toBeBoolean = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to {0} be Boolean&quot;.t(this.isNot ? &quot;not&quot; : &quot;&quot;);
        };
        return hlp.isOfType(this.actual, &#x27;Boolean&#x27;);
    };


    /**
     * @return {Boolean}
     */
    customMatchers.toBeNonEmptyString = function () {
        if (!bjQuery) {
            return false;
        }

        this.message = function () {
            var msg = &quot;&quot;;
            if (bjQuery) {
                msg = &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to &quot; + hlp.isNot(this, &quot;&quot;) + &quot;be a non empty string &quot;;
            } else {
                msg = hlp.msg.jQuery;
            }
            return msg;
        };
        return hlp.isOfType(this.actual, &#x27;String&#x27;) &amp;&amp; $.trim(this.actual).length &gt; 0;
    };

    /**
     */
    matchers.toBeNumber = function () {
        var test = function (actual, isNot) {
            var result = hlp.isNumber(actual);
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; to &quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; be a number&quot;
            };
        };

        return hlp.evaluate.call(this, test);
    };

    matchers.toBeEvenNumber = function () {
        var test = function (actual, isNot) {
            var result = hlp.isNumber(actual) &amp;&amp; actual % 2 === 0;
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; to &quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; be an even number&quot;
            };
        };

        return hlp.evaluate.call(this, test);
    };

    matchers.toBeOddNumber = function () {
        var test = function (actual, isNot) {
            var result = hlp.isNumber(actual) &amp;&amp; actual % 2 !== 0;
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; to &quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; be an odd number&quot;
            };
        };

        return hlp.evaluate.call(this, test);
    };

    matchers.toBeNaN = function () {
        var test = function (actual, isNot) {
            var result = isNaN(actual);
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &#x27;&quot; + hlp.dp(actual) + &quot;&#x27; to&quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; be a [NaN]&quot;
            };
        };

        return hlp.evaluate.call(this, test);
    };

    /**
     * @return {Boolean}
     */
    customMatchers.toBeFunction = function () {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to &quot; + hlp.isNot(this, &quot;&quot;) + &quot; be a [Function]&quot;;
        };
        return hlp.isOfType(this.actual, &#x27;Function&#x27;);
    };

    matchers.toHaveLength = function () {
        var test = function (actual, isNot, expected) {
            hlp.checkArgumentType(actual, &#x27;string&#x27;);
            hlp.checkArgumentType(expected, &#x27;number&#x27;);
            var result = actual.length === expected;
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; to &quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; have a length of &quot; + expected + &quot; but was &quot; + actual.length
            };
        };

        return hlp.evaluate.call(this, test);
    };

    matchers.toStartWith = function () {
        var test = function (actual, isNot, expected) {
            hlp.checkArgumentType(actual, &#x27;string&#x27;);
            hlp.checkArgumentType(expected, &#x27;string&#x27;);
            var result = hlp.startsWith(actual, expected);
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; to &quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; to start with &quot; + expected
            };
        };

        return hlp.evaluate.call(this, test);
    };

    matchers.toEndWith = function () {
        var test = function (actual, isNot, expected) {
            hlp.checkArgumentType(actual, &#x27;string&#x27;);
            hlp.checkArgumentType(expected, &#x27;string&#x27;);
            var result = hlp.endsWith(actual, expected);
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; to &quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; to ends with &quot; + expected
            };
        };

        return hlp.evaluate.call(this, test);
    };

    matchers.toContainOnce = function () {
        var test = function (actual, isNot, expected) {
            hlp.checkArgumentType(actual, &#x27;string&#x27;);
            hlp.checkArgumentType(expected, &#x27;string&#x27;);
            var result = false, firstFoundAt;
            if (actual) {
                firstFoundAt = actual.indexOf(expected);
                result = firstFoundAt !== -1 &amp;&amp; firstFoundAt === actual.lastIndexOf(expected);
            }
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; to &quot; + (isNot ? &quot; not&quot; : &quot;&quot;) + &quot; to contain only one &quot; + expected
            };
        };

        return hlp.evaluate.call(this, test);
    };

    customMatchers.toContainSelector = function (selector) {
        this.message = function () {
            return &quot;Expected &#x27;&quot; + hlp.dp(this.actual) + &quot;&#x27; to have contain &#x27;&quot; + hlp.dp(selector) + &quot;&#x27;.&quot;;
        };
        return this.actual.find(selector).length;
    };

    matchers.toBeUniqueArray = function () {
        var test = function (actual, isNot) {
            hlp.checkArgumentType(actual, &#x27;array&#x27;);
            var result = true, i, len = actual.length, o = [];

            // iterate over the array, adding unique elements to o
            for (i = 0; i &lt; len; i += 1) {
                if (hlp.indexOf(o, actual[i]) === -1) {
                    o.push(actual[i]);
                } else {
                    result = false;
                    break;
                }
            }
            return {
                pass : isNot ? !result : result,
                message : &quot;Expected &quot; + hlp.dp(actual) + &quot; values {0} to be unique&quot;.t(isNot ? &quot;not&quot; : &quot;&quot;)
            };
        };
        return hlp.evaluate.call(this, test);
    };

    /**
     *
     * @method matchers.toMatchDatePart
     * @param expected {Date} Date to be compared
     * @param {String} part specific part/property of the date you want to be compared &lt;/br
     *        &lt;br /&gt;
     *        &lt;b&gt;Currently supported parts are listed below :&lt;/b&gt;
     *        &lt;ul&gt;
     *            &lt;li&gt;date&lt;/li&gt;
     *            &lt;li&gt;day&lt;/li&gt;
     *            &lt;li&gt;month&lt;/li&gt;
     *            &lt;li&gt;year&lt;/li&gt;
     *            &lt;li&gt;milliseconds&lt;/li&gt;
     *            &lt;li&gt;minutes&lt;/li&gt;
     *            &lt;li&gt;seconds&lt;/li&gt;
     *            &lt;li&gt;hours&lt;/li&gt;
     *            &lt;li&gt;time&lt;/li&gt;
     *        &lt;/ul&gt;
     *  e.g usages :expect(date).toMatchDatePart(date, &#x27;day&#x27;);
     * @beta
     */
    matchers.toMatchDatePart = function () {
        var test = function (actual, isNot, expected) {
            hlp.checkArgumentType(actual, &#x27;date&#x27;);
            hlp.checkArgumentType(expected, &#x27;object&#x27;);
            hlp.checkArgumentType(expected.date, &#x27;date&#x27;);
            hlp.checkArgumentType(expected.part, &#x27;string&#x27;);
            var result, msg;

            switch (expected.part) {
            case &#x27;date&#x27;:
                result = actual.getDate() === expected.date.getDate();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getDate()), hlp.dp(expected.date.getDate()));
                break;
            case &#x27;day&#x27;:
                result = actual.getDay() === expected.date.getDay();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getDay()), hlp.dp(expected.date.getDay()));
                break;
            case &#x27;month&#x27;:
                result = actual.getMonth() === expected.date.getMonth();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getMonth()), hlp.dp(expected.date.getMonth()));
                break;
            case &#x27;year&#x27;:
                result = actual.getFullYear() === expected.date.getFullYear();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getFullYear()), hlp.dp(expected.date.getFullYear()));
                break;
            case &#x27;milliseconds&#x27;:
                result = actual.getMilliseconds() === expected.date.getMilliseconds();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getMilliseconds()), hlp.dp(expected.date.getMilliseconds()));
                break;
            case &#x27;seconds&#x27;:
                result = actual.getSeconds() === expected.date.getSeconds();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getSeconds()), hlp.dp(expected.date.getSeconds()));
                break;
            case &#x27;minutes&#x27;:
                result = actual.getMinutes() === expected.date.getMinutes();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getMinutes()), hlp.dp(expected.date.getMinutes()));
                break;
            case &#x27;hours&#x27;:
                result = actual.getHours() === expected.date.getHours();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getHours()), hlp.dp(expected.date.getHours()));
                break;
            case &#x27;time&#x27;:
                result = actual.getTime() === expected.date.getTime();
                msg = hlp.msg.date.nomatch.Date.t(hlp.dp(actual.getTime()), hlp.dp(expected.date.getTime()));
                break;
            default:
                msg = hlp.msg.date.nomatch.part.t(expected.part);
            }

            return {
                pass : isNot ? !result : result,
                message : msg
            };
        };

        return hlp.evaluate.call(this, test);
    };

    // aliases
    jasmine.addMatchers(matchers);

    // Keep a reference to the original matchers, for tests
    jasmine.__angular_jasmine_matchers__ = matchers;
});
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
